package simplejson

import (
	"fmt"
	"strings"

	. "github.com/dave/jennifer/jen"
	"github.com/iancoleman/orderedmap"
	"github.com/sindbach/json-to-bson-go/jsonutil"
	"github.com/sindbach/json-to-bson-go/options"
)

func Convert(jsonStr []byte, opts *options.Options) (string, error) {
	if opts == nil {
		opts = options.NewOptions()
	}

	input, err := jsonutil.Unmarshal(jsonStr)
	if err != nil {
		return "", err
	}

	generatedStructs, err := convertMapToStructs(input, opts, opts.StructName())
	if err != nil {
		return "", err
	}

	output := NewFile("main")
	for idx, gs := range generatedStructs {
		if idx != 0 {
			output.Line()
		}
		output.Type().Id(gs.name).Struct(gs.fields...)
	}
	return output.GoString(), nil
}

type generatedStruct struct {
	name   string
	fields []Code
}

func convertMapToStructs(input *orderedmap.OrderedMap, opts *options.Options, structName string) ([]generatedStruct, error) {
	var allStructs []generatedStruct
	var topLevelFields []Code

	for _, key := range input.Keys() {
		val, _ := input.Get(key)
		structTags := []string{key}

		elemKey := strings.Title(key)
		elem := Id(elemKey)
		switch converted := val.(type) {
		case []interface{}:
			nestedField, err := getArrayStatement(converted, opts, elemKey)
			if err != nil {
				return nil, fmt.Errorf("error processing array for key %q: %w", key, err)
			}
			structTags = append(structTags, "omitempty")

			if nestedField != nil {
				elem.Add(Index().Add(nestedField))
			} else {
				elem.Add(Index().Interface())
			}
		case orderedmap.OrderedMap:
			// The name of the nested struct type will always be the field name, so we can pass elemKey as the struct
			// name. For example, a JSON input of {a: {b: 1}} will become
			//
			// type AutoGenerated struct {
			//    A A `bson:"a"`
			// }
			// type A struct {
			//    B int32 `bson:"b"`
			// }
			nestedStructs, err := convertMapToStructs(&converted, opts, elemKey)
			if err != nil {
				return nil, fmt.Errorf("error processing nested document for key %q: %w", key, err)
			}

			allStructs = append(allStructs, nestedStructs...)
			// At this point, the line for the current field is "<field name>". We know the type name of the nested
			// struct is the same as the field name, so we can add elemKey to the line.
			elem.Add(Id(elemKey))
		default:
			fieldType, addTags, err := getFieldStatement(val, opts)
			if err != nil {
				return nil, err
			}

			elem.Add(fieldType)
			structTags = append(structTags, addTags...)
		}

		tagsString := strings.Join(structTags, ",")
		elem.Tag(map[string]string{"bson": tagsString})
		topLevelFields = append(topLevelFields, elem)
	}

	topLevelStruct := generatedStruct{
		name:   structName,
		fields: topLevelFields,
	}
	allStructs = append([]generatedStruct{topLevelStruct}, allStructs...)
	return allStructs, nil
}

func getFieldStatement(val interface{}, opts *options.Options) (*Statement, []string, error) {
	var structTags []string
	var statement *Statement

	switch converted := val.(type) {
	case string:
		statement = String()
	case bool:
		statement = Bool()
	case float64:
		if !opts.MinimizeIntegerSize() {
			statement = Float64()
			break
		}

		canTruncate := true
		switch {
		case float64(int32(converted)) == converted:
			statement = Int32()
		case float64(int64(converted)) == converted:
			statement = Int64()
		default:
			canTruncate = false
			statement = Float64()
		}

		if canTruncate && opts.TruncateIntegers() {
			structTags = append(structTags, "truncate")
		}
	case []interface{}, *orderedmap.OrderedMap:
		statement = Interface()
		if _, ok := val.([]interface{}); ok {
			structTags = append(structTags, "omitempty")
		}
	default:
		return nil, nil, fmt.Errorf("value has unrecognized type %T", val)
	}

	return statement, structTags, nil
}

func getArrayStatement(arr []interface{}, opts *options.Options, name string) (*Statement, error) {
	var retVal *Statement
	stillChecking := true

	for _, val := range arr {
		switch val.(type) {
		case []interface{}, *orderedmap.OrderedMap:
			stillChecking = false
			retVal = nil
		default:
			if stillChecking {
				fieldType, _, err := getFieldStatement(val, opts)
				if err != nil {
					return nil, err
				}
				if retVal == nil {
					retVal = fieldType
				} else if retVal.GoString() != fieldType.GoString() {
					stillChecking = false
					retVal = nil
				}
			}
		}
	}

	return retVal, nil
}
